\documentclass[a4paper,11pt,twoside]{article}
%\documentclass[a4paper,11pt,twoside,se]{article}

\usepackage{UmUStudentReport}
\usepackage{verbatim}   % Multi-line comments using \begin{comment}
\usepackage{courier}    % Nicer fonts are used. (not necessary)
\usepackage{pslatex}    % Also nicer fonts. (not necessary)
\usepackage[pdftex]{graphicx}   % allows including pdf figures
\usepackage{listings}
%\usepackage{lmodern}   % Optional fonts. (not necessary)
%\usepackage{tabularx}
%\usepackage{microtype} % Provides some typographic improvements over default settings
%\usepackage{placeins}  % For aligning images with \FloatBarrier
%\usepackage{booktabs}  % For nice-looking tables
%\usepackage{titlesec}  % More granular control of sections.

% DOCUMENT INFO
% =============
\department{Institution för Datavetenskap}
\coursename{Datavetenskapens byggstenar 7.5 p}
\coursecode{DV160HT15}
\title{OU4 Data Representation}
\author{Lorenz Gerber ({\tt{dv15lgr@cs.umu.se}})} 
\date{2016-03-03}
%\revisiondate{2016-01-18}
\instructor{Lena Kallin Westin / Johan Eliasson / Emil Marklund / Lina
Ögren}


% DOCUMENT SETTINGS
% =================
\bibliographystyle{plain}
%\bibliographystyle{ieee}
\pagestyle{fancy}
\raggedbottom
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
%\graphicspath{{images/}}   %Path for images

\usepackage{float}
\floatstyle{ruled}
\newfloat{listing}{thp}{lop}
\floatname{listing}{Listing}


% DEFINES
% =======
%\newcommand{\mycommand}{<latex code>}

% DOCUMENT
% ========
\begin{document}
\lstset{language=C}
\maketitle

\tableofcontents
\newpage

\section{Introduction} 
In this assignment the aim was to specify three different possible
data representations for a spreadsheet application. The
representations were to be described such that they could be implemented
from the descriptions. Several criteria to judge the suitability of
the chosen representations were discussed in the mandatory seminar
\emph{OU2}. Three of those criteria were then applied to judge the
chosen data representations.

It was chosen to structure the report into five parts: First an
\emph{introduction} where the aim of the work is presented. Second, the
\emph{interpretation of problem description} including also a short
reference to the chosen data representations and criterias. Third
comes an \emph{construction of the data types for each chosen data
  representation}. Then the \emph{evaluation according the chosen
  criteria}. And finally \emph{summarizing discussing} where also the
decision for the most suitable data representation is revealed.


\section{Interpretation of the Problem Description}
The problem description from the course homepage defines a spreadsheet
as a 'table'. Hence, a spreadsheet can be seen seen as a potentially
infinite table. A requirement given in the description is that the
implementation shall be more economic than an plain rectangular
structure covering all non-empty table elements. From those
descriptions it becomes obvious that a more concise description of
problem is the \emph{efficient implementation of a sparse matrix}. 

\subsection{Typical Usecases of a Spreadsheet}
During a user session, text, numbers, formulas and links to
other elements are stored in the table elements. In many usecases the
number of filled elements will be very low compared to the virtual
rectanglular set of elements that surrounds the outermost non-empty
table elements, hence the table is said to have a low \emph{fill
 ratio}. This is the main reason why the potential data structure
should only store non-empty elements.

Another important property of a spreadsheet program is that the data
structure is represented in the graphical user interface. Due to the
size, there will usually just one part of the data be visible, hence
blockwise value lookup for scrolling over the data table is a very
common operation.

Spreadsheets are often used to prepare sorted lists. Hence
rearranging the order of whole rows or columns is another operation of
high importance.

When spreadsheets are used for calculation purposes, extensive linking
between memeber elements of the spreadsheet is common. Links are
either between two elements, much in the style of a pointer, but then
can also be many elements to one cell, in the case of functions, such
as calculating the sum of multiple cells.


\subsection{Chosen Criteria}
\subsubsection{Time Complexity}
The speed of specific operations is an important criteria. In some
cases, it could decide whether a ceratin construction is feasible at
or not. Whith `speed' I would define the processing time needed at a
realistic use case size of the instance in question. Hence, sometimes
a bad complexity can be accepted as the typical realworld instance
size happens to be in a very narrow bandwith.
If possible, also the time complexity of individual operations will be
asessed.    

The chosen operations of interest are given below:

\begin{itemize}
\item Block Lookup - Get values for a block of cells. This operation
  will usally be applied when the user scrolls or jumps to another
  place in the spreadsheet. If row/column wise scrolling is assumed,
  typicall lookup sizes would be around 10 to 50. 
\item Link following - Lookup of links as used in functions. 
\item Deletion - Deleting elements of the spreadsheet.
\item Traversal - Traversing the data structure to search for a value
\end{itemize}

\subsubsection{Ease of Implementation}
During OU2 discussion, it was agreed that a lower complexity
of the implementation is generally desirable as it decreases the
susceptibility for bugs and code maintenance. Below are indicated some
features/operations for which the ease of implementation will be
judged and compared across the different table constructions.

\begin{itemize}
\item Basic Structure - The data container as such
\item Sort - Sorting larger blocks of non-empty elements
\end{itemize}

\subsubsection{Memory efficency}
It is understood from the problem definition that the used
construction shall just store non-empty spreadsheet elements. Hence
the judgement of memory efficency focuses on the amount of
memory used for `administratiion' of the non-empty elements, such as
hash tables and non value bearing data structure. 


\subsection{Chosen Datatypes}
The abstract datatypes that were chosen to be evaluated are:
\begin{itemize}
\item Array
\item Binary Tree
\item Directed Acyclic Graph
\end{itemize}



\section{Construction of Datatypes}
\subsection{Array}
The abstract datatype \emph{array} ressembles the description of 
how a spreadsheet is defined. However, when looking at the problem 
description, it became obvious that the physical datatype array was 
not suited as representation as an \emph{efficient representation of a
 sparse matrix}. Janlert \cite[pp 101-103]{janlert2000} suggest in
such a case to construct the array from a vector of tables. In C, the
array is a physical datatype. Typical for the datatype array, it can
not be resized during runtime. Hence this construction interpretes the
requirement of a infinite large spreadsheet by chosing a large enough
length for the row dimension. This seems to be an accepted choice:
\textit{Microsoft Excel}, one of the arguably most popular spreadsheet
applications on the market, has for example a row/column limitation of
1'048'576/16'384 \cite{excel_limit}.

There is no physical datatype table in C. In this case construction
from a dynamic datatype such as linked list seems to be reasonable. As
there is also no physical datatype List in C, the construction could
be done through the complex data type struct linked with pointers. An
example of the datatypes list and table implemented in such a way can
be found on the course web page. 
 

\subsection{Binary trees}
Binary search trees offer a good time complexity. A table can be
implemented as one tree for the rows and multiple trees for the
columns in each row. 

\subsection{Directed Acyclic Graph and Hash Table}
A directed graph is an n-linked structure. The nodes can be
constructed as cells. The cells are created dynamically on demand. 
Edges represent links in the spreadsheet. They are also created 
dynamically. Direct access to individual nodes can be achieved by a hash
table. 

 

\section{Evaluation of Data Representations}


\section{Discussion}
And our results looked like this...


\addcontentsline{toc}{section}{\refname}
\bibliography{references}

\end{document}
