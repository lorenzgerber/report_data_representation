\documentclass[a4paper,11pt,twoside]{article}
%\documentclass[a4paper,11pt,twoside,se]{article}

\usepackage{UmUStudentReport}
\usepackage{verbatim}   % Multi-line comments using \begin{comment}
\usepackage{courier}    % Nicer fonts are used. (not necessary)
\usepackage{pslatex}    % Also nicer fonts. (not necessary)
\usepackage[pdftex]{graphicx}   % allows including pdf figures
\usepackage{listings}
%\usepackage{lmodern}   % Optional fonts. (not necessary)
%\usepackage{tabularx}
%\usepackage{microtype} % Provides some typographic improvements over default settings
%\usepackage{placeins}  % For aligning images with \FloatBarrier
%\usepackage{booktabs}  % For nice-looking tables
%\usepackage{titlesec}  % More granular control of sections.

% DOCUMENT INFO
% =============
\department{Institution för Datavetenskap}
\coursename{Datavetenskapens byggstenar 7.5 p}
\coursecode{DV160HT15}
\title{OU4 Data Representation}
\author{Lorenz Gerber ({\tt{dv15lgr@cs.umu.se}})} 
\date{2016-03-03}
%\revisiondate{2016-01-18}
\instructor{Lena Kallin Westin / Johan Eliasson / Emil Marklund / Lina
Ögren}


% DOCUMENT SETTINGS
% =================
\bibliographystyle{plain}
%\bibliographystyle{ieee}
\pagestyle{fancy}
\raggedbottom
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
%\graphicspath{{images/}}   %Path for images

\usepackage{float}
\floatstyle{ruled}
\newfloat{listing}{thp}{lop}
\floatname{listing}{Listing}


% DEFINES
% =======
%\newcommand{\mycommand}{<latex code>}

% DOCUMENT
% ========
\begin{document}
\lstset{language=C}
\maketitle

\tableofcontents
\newpage

\section{Introduction} 
In this assignment the aim was to specify three different possible
data representations for a spreadsheet application. The
representations were to be described such that they could be implemented
from the descriptions. Several criteria to judge the suitability of
the chosen representations were discussed in the mandatory seminar
\emph{OU2}. Three of those criteria were then applied to judge the
chosen data representations.

It was chosen to structure the report into five parts: First an
\emph{introduction} where the aim of the work is presented. Second, the
\emph{interpretation of problem description} including also a short
reference to the chosen data representations and criterias. Third
comes an \emph{construction of the data types for each chosen data
  representation}. Then the \emph{evaluation according the chosen
  criteria}. And finally \emph{summarizing discussing} where also the
decision for the most suitable data representation is revealed.


\section{Interpretation of the Problem Description}
The problem description from the course homepage defines a spreadsheet
as a 'table'. Hence, a spreadsheet can be seen seen as a potentially
infinite table. A requirement given in the description is that the
implementation shall be more economic than an plain rectangular
structure covering all non-empty table elements. From those
descriptions it becomes obvious that a more concise description of
problem is the \emph{efficient implementation of a sparse matrix}. 

\subsection{Typical Usecases of a Spreadsheet}
During a user session, text, numbers, formulas and links to
other elements are stored in the table elements. In many usecases the
number of filled elements will be very low compared to the virtual
rectanglular set of elements that surrounds the outermost non-empty
table elements, hence the table is said to have a low \emph{fill
 ratio}. This is the main reason why the potential data structure
should only store non-empty elements.

Another property of a spreadsheet program is that the data
structure is represented in the graphical user interface. Due to the
size, there will usually just one part of the data be visible, hence
blockwise value lookup for scrolling over the data table is a very
common operation. Spreadsheets are often used to prepare sorted
lists. Hence rearranging the order of whole rows or columns is another
operation of importance. When spreadsheets are used for calculation
purposes, extensive linking between memeber elements of the
spreadsheet is common.


\subsection{Chosen Criteria}
\subsubsection{Time Complexity}
The speed of specific operations is an important criteria. In some
cases, it could decide whether a ceratin construction is feasible at
or not. Whith `speed' I would define the processing time needed at a
realistic use case size of the instance in question. Hence, sometimes
a bad complexity can be accepted as the typical realworld instance
size happens to be in a very narrow bandwith.
If possible, also the time complexity of individual operations will be
asessed.    

The chosen operations of interest are given below:

\begin{itemize}
\item Block Lookup - Get values for a block of cells. This operation
  will usally be applied when the user scrolls or jumps to another
  place in the spreadsheet. If row/column wise scrolling is assumed,
  typicall lookup sizes would be around 10 to 50. 
\item Deletion - Deleting elements of the spreadsheet.
\item Element Search - Traversing the data structure to search for a value
\end{itemize}

\subsubsection{Ease of Implementation}
During OU2 discussion, it was agreed that a lower complexity
of the implementation is generally desirable as it decreases the
susceptibility for bugs and code maintenance. Below are indicated some
features/operations for which the ease of implementation will be
judged and compared across the different table constructions.

\begin{itemize}
\item Basic Structure - The data container as such
\item Sort - Sorting larger blocks of non-empty elements
\end{itemize}

\subsubsection{Memory efficency}
It is understood from the problem definition that the used
construction shall just store non-empty spreadsheet elements. Hence
the judgement of memory efficency focuses on the amount of
memory used for `administratiion' of the non-empty elements, such as
hash tables and non value bearing data structure. 


\subsection{Chosen Datatypes}
The abstract datatypes that were chosen to be evaluated are:
\begin{itemize}
\item Array
\item Binary Tree
\item Directed Acyclic Graph
\end{itemize}



\section{Construction of Datatypes}
\subsection{Array}
The abstract datatype \emph{array} ressembles the description of 
how a spreadsheet is defined. However, when looking at the problem 
description, it became obvious that the physical datatype array was 
not suited as representation as an \emph{efficient representation of a
 sparse matrix}. Janlert \cite[pp 101-103]{janlert2000} suggest in
such a case to construct the array from a vector of tables. In C, the
array is a physical datatype. Typical for the datatype array, it can
not be resized during runtime. Hence this construction interpretes the
requirement of a infinite large spreadsheet by chosing a large enough
length for the row dimension. This seems to be an accepted choice:
\textit{Microsoft Excel}, one of the arguably most popular spreadsheet
applications on the market, has for example a row/column limitation of
1'048'576/16'384 \cite{excel_limit}.

There is no physical datatype \textit{table} in C. In this case construction
from a dynamic datatype such as \textit{linked list} seems to be reasonable. As
there is also no physical datatype \textit{list} in C, the construction could
be done through the complex datatype \textit{struct} linked with
\textit{pointers}. An example of the datatypes \textit{list} and
\textit{table} implemented as described above is available on the course
web page \cite{datatypes}.

In this construction, rows are accessed directly through the array
index and columns by looking up the value associated to the key that
represents the column number (the course litterature uses
the word \textit{argument} instead of \textit{key}\cite{janlert2000}). 
 

\subsection{Binary trees}
\textit{Binary search trees} offer a good time complexity. Therefore
they were also considered for construction of a table trees. 
Here, the row index was represented in one \textit{binary tree}. The
label of each node contains the row index and a pointer to
another \textit{binary tree} for representing the column indices. 
Hence, for each node of the row tree, there is an additional column
\textit{binary tree}. The nodes in the column trees have a label that
contains both the column index and the actual value. 

In C, the construction of a binary tree is by using pointers to link
structs. An implementation according to Janlert was available through
the course homepage \cite{datatypes}.



\subsection{Directed Acyclic Graph and Hash Table}
When thinking about the \emph{link} or \emph{reference} feature that most
spreadsheets make heavy use upon, a table constructed from a graph
becomes an intersting possibility.  A directed acyclic graph or
\textit{DAG} is an n-linked structure. The nodes can be
constructed as cells which are created dynamically on demand. In C, a
struct would be the natural choice. Edges represent links in the
spreadsheet. They are also created dynamically. 

To access individual cells, a hash table with a continuous numbering
system either along the rows or columns of the table can be
used. Alternatively, the number to put in the hash table can be the
concatenation of the spreadsheet table coordinates. In C a
datatype \textit{hash table} is not available by default and has to be
constructed. The underlying datatype is a table as described
earlier. For simplicity, \emph{open hashing} with \emph{linear
  probing} and a simple hash function such as \textit{modulo} was
chosen \cite[p. 277]{janlert2000}. 


\section{Evaluation of Data Representations}
All data representations are evaluated seperately and later compared
in the discussion section.
\subsection{Time Complexity}
\subsubsection{Array}
Looking up values in a spreadsheet is always a composite of both row
and column lookup. Here, the column lookup is of O(1) while the column
lookup is of O(n). Hence, \emph{Block Lookup} in this representation
is in the order of O(n) because of the \textit{table}. \emph{Deletion}
of spreadsheet elements also of O(n). \emph{Searching} for values is
rather slow as the whole data structure has to be traversed, hence,
the time complexity is in the order of O(n).

\subsubsection{Binary Tree}
Average value lookup in binary trees is in the order of O(log(n)),
which is also the complexity for \emph{Block Lookup}. \emph{Deletions}
are of the same time complexity, however, significant structural
reshuffeling is needed when nodes close to the root have to be
deleted. \emph{Searching} for values is this case just O(n) as all
nodes have to be traversed. This is because the order relation in the
binary trees is based on their coordinate values and not on the user
value entered in a spreadsheet cell.

\subsubsection{Direced Acyclic Graph (DAG) with Hash Table}
Lookup speeds in a \textit{hashtable} are in the order of O(1) which
applies also to \emph{Block Lookup} speed. The same is true for
\emph{Deletions}. \emph{Searching} is on an avarage O(n) as all stored values
have to be looked up. This is a consquence of the fact that we are
hashing for spreadsheet coordinates and not spreadsheet element user
values. The fact that the whole structure is implemented as a DAG has
no inflence on the time complexity here. 

\subsection{Ease of Implementation}
\subsubsection{Array}
Implementing a spreadsheet using \textit{array} as data representation
is straight forward as a spreadsheet basically is an array. In the
current case the array needs to be constructed from a vector of
tables, but these are still rather simple datatypes and they are all
available on the course homepage.

\subsubsection{Binary Tree}
Building the basic structure of the \textit{binary tree}
implementation is also rather simple as the underlying data
types are available on the course homepage. However, the whole
representation feels less intuitive because a tree does not really
ressembles a spreadsheet.

\subsubsection{Directed Acyclic Graph (DAG) with Hash Table}
The DAG purely as structure is simple to implement: The individual
nodes are basically a dynamic resource that is allocated when needed
and removed on deletion. However, implementing a hash table in C is
certainly not trivial and will require a fair amount of work. 

\section{Discussion}
And our results looked like this...


\addcontentsline{toc}{section}{\refname}
\bibliography{references}

\end{document}
